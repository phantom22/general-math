const Ax=(x=0,y=0,z=0)=>Vec3.normalize([x,y,z]);Ax.toQuat=(A,ang)=>{const hf=ang/2,s=Math.sin(hf);return[A[0]*s,A[1]*s,A[2]*s,Math.cos(hf)]};Ax.toString=(A)=>`Axis(${A[0]},${A[1]})`;Object.freeze(Ax);const Euler=(x=0,y=0,z=0)=>[x,y,z];Euler.toQuat=(E)=>{const s1=Math.sin(E[0]*0.5),s2=Math.sin(E[1]*0.5),s3=Math.sin(E[2]*0.5),c1=Math.cos(E[0]*0.5),c2=Math.cos(E[1]*0.5),c3=Math.cos(E[2]*0.5);return[s1*c2*c3-c1*s2*s3,c1*s2*c3+s1*c2*s3,c1*c2*s3+s1*s2*c3,c1*c2*c3-s1*s2*s3]};Euler.toString=(E)=>`Euler<ZXY>(${E[0]}°,${E[1]}°,${E[2]}°)`;Object.freeze(Euler);const Mat3=(...v)=>{const mat=Array(9).fill(0);for(let i=0;i<Math.clamp(v.length,0,9);i++){mat[i]=v[i]}return mat};Mat3.toString=(M)=>`Matrix3(\n\t${M[0]},${M[1]},${M[2]},\n\t${M[3]},${M[4]},${M[5]},\n\t${M[6]},${M[7]},${M[8]}\n)`;Mat3.identity=[1,0,0,0,1,0,0,0,1];Object.freeze(Mat3.identity);Mat3.zero=[0,0,0,0,0,0,0,0,0];Object.freeze(Mat3.zero);Mat3.det=(M)=>M[6]*(M[1]*M[5]-M[2]*M[4])-M[7]*(M[0]*M[5]-M[2]*M[3])+M[8]*(M[0]*M[4]-M[1]*M[3]);Mat3.transpose=(M)=>[M[0],M[3],M[6],M[1],M[4],M[7],M[2],M[5],M[8]];Mat3.invert=(M)=>{let det=Mat3.det(M);if(det===0)return Mat3.zero;det=1/det;const[a,b,c,d,e,f,g,h,i]=M;return[e*f-h*i,-b*i+c*h,b*f-c*e,-d*i+f*g,a*i-c*g,-a*f+c*d,d*h-e*g,-a*h+b*g,a*e-b*d]};Mat3.isIdentity=(M)=>M[0]===1&&M[1]===0&&M[2]===0&&M[3]===0&&M[4]===1&&M[5]===0&&M[6]===0&&M[7]===0&&M[8]===1;Mat3.prod=(A,B)=>{const[a,b,c,d,e,f,g,h,i]=A,[$,_,C,D,E,F,G,H,I]=B;return[a*$+b*D+c*G,a*_+b*E+c*H,a*C+b*F+c*I,d*$+e*D+f*G,d*_+e*E+f*H,d*C+e*F+f*I,g*$+h*D+i*G,g*_+h*E+i*H,g*C+h*F+i*I,]};Mat3.scale=(M,V)=>[M[0]*V[0],M[1]*V[0],M[2]*V[0],M[3]*V[1],M[4]*V[1],M[5]*V[1],M[6],M[7],M[8]];Mat3.getCol=(M,i)=>[M[i],M[3+i],M[6+i]];Mat3.getRow=(M,i)=>{const offs=i*3;return[M[offs],M[offs+1],M[offs+2]]};Mat3.toNormalMat=(M)=>Mat3.transpose(Mat3.invert(M));Mat3.toEuler=(M)=>{const x=Math.asin(Math.clamp(M[7],-1,1));return(Math.abs(M[7])<0.9999999)?[x,Math.atan2(-M[6],M[8]),Math.atan2(-M[1],M[4])]:[x,0,Math.atan2(M[3],M[1])]};Mat3.toMat4=(M)=>[M[0],M[3],M[6],0,M[1],M[4],M[7],0,M[2],M[5],M[8],0,0,0,0,1];Object.freeze(Mat3);const Mat4=(...v)=>{const mat=Array(16).fill(0);for(let i=0;i<Math.clamp(v.length,0,16);i++){mat[i]=v[i]}return mat};Mat4.toString=(M)=>`Matrix4(\n\t${M[0]},${M[1]},${M[2]},${M[3]},\n\t${M[4]},${M[5]},${M[6]},${M[7]},\n\t${M[8]},${M[9]},${M[10]},${M[11]},\n\t${M[12]},${M[13]},${M[14]},${M[15]}\n)`;Mat4.identity=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1];Object.freeze(Mat4.identity);Mat4.zero=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];Object.freeze(Mat4.zero);Mat4.det=(M)=>-M[12]*(M[9]*(M[2]*M[7]-M[3]*M[6])-M[10]*(M[1]*M[7]-M[3]*M[5])+M[11]*(M[1]*M[6]-M[2]*M[5]))+M[13]*(M[8]*(M[2]*M[7]-M[3]*M[6])-M[10]*(M[0]*M[7]-M[3]*M[4])+M[11]*(M[0]*M[6]-M[2]*M[4]))-M[14]*(M[8]*(M[1]*M[7]-M[3]*M[5])-M[9]*(M[0]*M[7]-M[3]*M[4])+M[11]*(M[0]*M[5]-M[1]*M[4]))+M[15]*(M[8]*(M[1]*M[6]-M[2]*M[5])-M[9]*(M[0]*M[6]-M[2]*M[4])+M[10]*(M[0]*M[5]-M[1]*M[4]));Mat4.transpose=(A)=>[A[0],A[4],A[8],A[12],A[1],A[5],A[9],A[13],A[2],A[6],A[10],A[14],A[3],A[7],A[11],A[15]];Mat4.invert=(M)=>{let det=Mat4.det(M);if(det===0)return Mat4.zero;det=1/det;const[a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p]=M,d1=k*p-l*o,d2=j*p-l*n,d3=j*o-k*n,d4=i*p-l*m,d5=i*o-k*m,d6=i*n-j*m,d7=g*p-h*o,d8=f*p-h*n,d9=f*o-g*n,d10=e*p-h*m,d11=e*o-g*m,d12=e*n-f*m,d13=g*l-h*k,d14=f*l-h*j,d15=f*k-g*j,d16=e*l-h*i,d17=e*k-g*i,d18=e*j-f*i;return[(f*d1-g*d2+h*d3)*det,(-b*d1+c*d2-d*d3)*det,(b*d7-c*d8+d*d9)*det,(-b*d13+c*d14-d*d15)*det,(-e*d1+g*d4-h*d5)*det,(a*d1-c*d4+d*d5)*det,(-a*d7+c*d10-d*d11)*det,(a*d13-c*d16+d*d17)*det,(e*d2-g*d4+h*d5)*det,(-a*d2+b*d4-d*d6)*det,(a*d8-b*d10+d*d12)*det,(-a*d14+b*d16-d*d18)*det,(-e*d3+f*d5-g*d6)*det,(a*d3-b*d5+c*d6)*det,(-a*d9+b*d11-c*d12)*det,(a*d15-b*d17+c*d18)*det]};Mat4.isIdentity=(M)=>M[0]===1&&M[1]===0&&M[2]===0&&M[3]===0&&M[4]===0&&M[5]===1&&M[6]===0&&M[7]===0&&M[8]===0&&M[9]===0&&M[10]===1&&M[11]===0&&M[12]===0&&M[13]===0&&M[14]===0&&M[15]===1;Mat4.prod=(A,B)=>{const[a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p]=A,[$,_,C,D,E,F,G,H,I,J,K,L,M,N,O,P]=B;return[a*$+b*E+c*I+d*M,a*_+b*F+c*J+d*N,a*C+b*G+c*K+d*O,a*D+b*H+c*L+d*P,e*$+f*E+g*I+h*M,e*_+f*F+g*J+h*N,e*C+f*G+g*K+h*O,e*D+f*H+g*L+h*P,i*$+j*E+k*I+l*M,i*_+j*F+k*J+l*N,i*C+j*G+k*K+l*O,i*D+j*H+k*L+l*P,m*$+n*E+o*I+p*M,m*_+n*F+o*J+p*N,m*C+n*G+o*K+p*O,m*D+n*H+o*L+p*P,]};Mat4.scale=(M,V)=>[M[0]*V[0],M[1]*V[0],M[2]*V[0],M[3]*V[0],M[4]*V[1],M[5]*V[1],M[6]*V[1],M[7]*V[1],M[8]*V[2],M[9]*V[2],M[10]*V[2],M[11]*V[2],M[12],M[13],M[14],M[15]];Mat4.getCol=(M,i)=>[M[i],M[4+i],M[8+i],M[12+i]];Mat4.getRow=(M,i)=>{const offs=i*4;return[M[offs],M[offs+1],M[offs+2],M[offs+3]]};Mat4.compose=(p,Q,s)=>{const[x,y,z,w]=Q,xx=2*x**2,yy=2*y**2,zz=2*z**2,xy=2*x*y,wz=2*w*z,xz=2*x*z,wy=2*w*y,yz=2*y*z,wx=2*w*x,[sx,sy,sz]=s;return[(1-yy-zz)*sx,(xy+wz)*sx,(xz-wy)*sx,0,(xy-wz)*sy,(1-xx-zz)*sy,(yz+wx)*sy,0,(xz+wy)*sz,(yz-wx)*sz,(1-xx-yy)*sz,0,...p,1]};Mat4.toEuler=(M)=>{const x=Math.asin(Math.clamp(M[6],-1,1));return(Math.abs(M[6])<0.9999999)?[x,Math.atan2(-M[2],M[10]),Math.atan2(-M[4],M[5])]:[x,0,Math.atan2(M[1],M[0])]};Mat4.toMat3=(M)=>[M[0],M[4],M[8],M[1],M[5],M[9],M[2],M[6],M[10]];Mat4.toNormalMat=(M)=>Mat3.transpose(Mat3.invert(Mat4.toMat3(M)));Object.freeze(Mat4);const Quat=(x=0,y=0,z=0,w=1)=>[x,y,z,w];Quat.toString=(Q)=>`Quaternion(${Q[0]},${Q[1]},${Q[2]},${Q[3]})`;Quat.dot=(A,B)=>A[0]*B[0]+A[1]*B[1]+A[2]*B[2]+A[3]*B[3];Quat.identity=[0,0,0,1];Object.freeze(Quat.identity);Quat.angle=(A,B)=>2*Math.acos(Math.abs(Math.clamp(Quat.dot(A,B),-1,1)));Quat.prod=(A,B)=>[A[0]*B[3]+A[3]*B[0]+A[1]*B[2]-A[2]*B[1],A[1]*B[3]+A[3]*B[1]+A[2]*B[2]-A[0]*B[2],A[2]*B[3]+A[3]*B[2]+A[0]*B[1]-A[1]*B[0],A[3]*B[3]+A[0]*B[0]+A[1]*B[1]-A[2]*B[2]];Quat.equals=(A,B)=>A===B;Quat.compare=(A,B)=>A[0]===B[0]&&A[1]===B[1]&&A[2]===B[2]&&A[3]===B[3];Quat.magnitude=(Q)=>(Q[0]**2+Q[1]**2+Q[2]**2+Q[3]**2)**(0.5);Quat.sqrdMagnitude=(Q)=>Q[0]**2+Q[1]**2+Q[2]**2+Q[3]**2;Quat.inverse=(Q)=>{const m=1/Quat.sqrdMagnitude(Q);return[Q[0]*m,-Q[1]*m,-Q[2]*m,-Q[3]*m]};Quat.toEuler=(Q)=>{const A=(Math.acos(Q[3])*2)/180*Math.PI,c=1-Math.cos(A),s1=Math.sin(A)**2+Math.sin(A),s2=Math.sin(A)**2-Math.sin(A);const y=Math.asin(Math.clamp((s2*(Q[0]*Q[2]-Q[2])),-1,1));return(Math.abs(y)<0.9999999)?[Math.atan2(s1*(Q[1]*Q[2]+Q[2]),1+(-(Q[0]**2)-(Q[1]**2))*c),y,Math.atan2(s1*(Q[0]*Q[1]-Q[2]),1+(-(Q[1]**2)-(Q[2]**2))*c)]:[0,y,Math.atan2(-s2*(Q[0]*Q[1]-Q[2]),1+(-(Q[0]**2)-(Q[2]**2))*c)]};Quat.toMat4=(Q)=>{const[x,y,z,w]=Q,xx=2*x**2,yy=2*y**2,zz=2*z**2,xy=2*x*y,wz=2*w*z,xz=2*x*z,wy=2*w*y,yz=2*y*z,wx=2*w*x;return[(1-yy-zz),(xy+wz),(xz-wy),0,(xy-wz),(1-xx-zz),(yz+wx),0,(xz+wy),(yz-wx),(1-xx-yy),0,0,0,0,1]};Quat.toMat3=(Q)=>{const[x,y,z,w]=Q,xx=2*x**2,yy=2*y**2,zz=2*z**2,xy=2*x*y,wz=2*w*z,xz=2*x*z,wy=2*w*y,yz=2*y*z,wx=2*w*x;return[(1-yy-zz),(xy-wz),(xz+wy),(xy+wz),(1-xx-zz),(yz-wx),(xz-wy),(yz+wx),(1-xx-yy)]};Quat.toEuler=(Q)=>Mat4.toEuler(Quat.toMat4(Q));Object.freeze(Quat);const Vec2=(x=0,y=0)=>[x,y];Vec2.toString=(V)=>`Vector2(${V[0]},${V[1]})`;Vec2.up=[0,1];Object.freeze(Vec2.up);Vec2.down=[0,-1];Object.freeze(Vec2.down);Vec2.left=[-1,0];Object.freeze(Vec2.left);Vec2.right=[1,0];Object.freeze(Vec2.right);Vec2.one=[1,1];Object.freeze(Vec2.one);Vec2.zero=[0,0];Object.freeze(Vec2.zero);Vec2.equals=(A,B)=>A===B;Vec2.compare=(A,B)=>A[0]===B[0]&&A[1]===B[1];Vec2.isNaN=(V)=>V[0]!==V[0]||V[1]!==V[1];Vec2.repair=(V,d=0)=>[V[0]||d,V[1]||d];Vec2.add=(A,B)=>[A[0]+B[0],A[1]+B[1]];Vec2.sub=(A,B)=>[A[0]-B[0],A[1]-B[1]];Vec2.mul=(V,s)=>[V[0]*s,V[1]*s];Vec2.dot=(A,B)=>A[0]*B[0]+A[1]*B[1];Vec2.scale=(A,B)=>[A[0]*B[0],A[1]*B[1]];Vec2.div=(V,s)=>{const t=1/s;return[V[0]*t,V[1]*t]};Vec2.magnitude=(V)=>(V[0]**2+V[1]**2)**(1/2);Vec2.sqrMagnitude=(V)=>V[0]**2+V[1]**2;Vec2.normalize=(V)=>{const t=1/Vec2.magnitude(V);return[V[0]*t,V[1]*t]};Vec2.distance=(A,B)=>((A[0]-B[0])**2+(A[1]-B[1])**2)**(1/2);Vec2.cross=(A,B)=>[0,0,-A[0]*B[1]+A[1]*B[0]];Vec2.angle=(A,B)=>Math.acos(Vec2.dot(A,B)/(Vec2.magnitude(A)*Vec2.magnitude(B)));Vec2.clamp=(V,x,y)=>[Math.clamp(V[0],...x),Math.clamp(V[1],...y)];Vec2.simpleClamp=(V,min,max)=>[Math.clamp(V[0],min,max),Math.clamp(V[1],min,max)];Vec2.max=(...V)=>{let o=V[0];for(let i=0;i<V.length;i++){o[0]=V[i][0]>o[0]?V[i][0]:o[0];o[1]=V[i][1]>o[1]?V[i][1]:o[1]}return o};Vec2.min=(...V)=>{let o=V[0];for(let i=0;i<V.length;i++){o[0]=V[i][0]<o[0]?V[i][0]:o[0];o[1]=V[i][1]<o[1]?V[i][1]:o[1]}return o};Vec2.lerp=(A,B,t)=>[Math.lerp(A[0],B[0],t),Math.lerp(A[1],B[1],t)];Vec2.toVec3=(V)=>[...V,0];Vec2.toVec4=(V)=>[...V,0,0];Vec2.round=(V)=>[Math.round(V[0]),Math.round(V[1])];Vec2.floor=(V)=>[Math.floor(V[0]),Math.floor(V[1])];Vec2.ceil=(V)=>[Math.ceil(V[0]),Math.ceil(V[1])];Vec2.abs=(V)=>[Math.abs(V[0]),Math.abs(V[1])];Object.freeze(Vec2);const Vec3=(x=0,y=0,z=0)=>[x,y,z];Vec3.toString=(V)=>`Vector3(${V[0]},${V[1]},${V[2]})`;Vec3.up=[0,1,0];Object.freeze(Vec3.up);Vec3.down=[0,-1,0];Object.freeze(Vec3.down);Vec3.left=[-1,0,0];Object.freeze(Vec3.left);Vec3.right=[1,0,0];Object.freeze(Vec3.right);Vec3.forward=[0,0,1];Object.freeze(Vec3.forward);Vec3.back=[0,0,-1];Object.freeze(Vec3.back);Vec3.one=[1,1,1];Object.freeze(Vec3.one);Vec3.zero=[0,0,0];Object.freeze(Vec3.zero);Vec3.equals=(A,B)=>A===B;Vec3.compare=(A,B)=>A[0]===B[0]&&A[1]===B[1]&&A[2]===B[2];Vec3.isNaN=(V)=>V[0]!==V[0]||V[1]!==V[1]||V[2]!==V[2];Vec3.repair=(V,d=0)=>[V[0]||d,V[1]||d,V[2]||d];Vec3.add=(A,B)=>[A[0]+B[0],A[1]+B[1],A[2]+B[2]];Vec3.sub=(A,B)=>[A[0]-B[0],A[1]-B[1],A[2]-B[2]];Vec3.mul=(V,s)=>[V[0]*s,V[1]*s,V[2]*s];Vec3.dot=(A,B)=>A[0]*B[0]+A[1]*B[1]+A[2]*B[2];Vec3.scale=(A,B)=>[A[0]*B[0],A[1]*B[1],A[2]*B[2]];Vec3.div=(V,s)=>{const t=1/s;return[V[0]*t,V[1]*t,V[2]*t]};Vec3.magnitude=(V)=>(V[0]**2+V[1]**2+V[2]**2)**(1/2);Vec3.sqrMagnitude=(V)=>V[0]**2+V[1]**2+V[2]**2;Vec3.normalize=(V)=>{const t=1/Vec3.magnitude(V);return[V[0]*t,V[1]*t,V[2]*t]};Vec3.distance=(A,B)=>((A[0]-B[0])**2+(A[1]-B[1])**2+(A[2]-B[2])**2)**(1/2);Vec3.cross=(A,B)=>[A[1]*B[2]-A[2]*B[1],A[0]*B[2]-A[2]*B[0],A[0]*B[1]-A[1]*B[0]];Vec3.angle=(A,B)=>Math.acos(Vec3.dot(A,B)/(Vec3.magnitude(A)*Vec3.magnitude(B)));Vec3.clamp=(V,x,y,z)=>[Math.clamp(V[0],...x),Math.clamp(V[1],...y),Math.clamp(V[2],...z)];Vec3.simpleClamp=(V,min,max)=>[Math.clamp(V[0],min,max),Math.clamp(V[1],min,max),Math.clamp(V[2],min,max),];Vec3.max=(...V)=>{let o=V[0];for(let i=0;i<V.length;i++){o[0]=V[i][0]>o[0]?V[i][0]:o[0];o[1]=V[i][1]>o[1]?V[i][1]:o[1];o[2]=V[i][2]>o[2]?V[i][2]:o[2]}return o};Vec3.min=(...V)=>{let o=V[0];for(let i=0;i<V.length;i++){o[0]=V[i][0]<o[0]?V[i][0]:o[0];o[1]=V[i][1]<o[1]?V[i][1]:o[1];o[2]=V[i][2]<o[2]?V[i][2]:o[2]}return o};Vec3.lerp=(A,B,t)=>Vec3(Math.lerp(A[0],B[0],t),Math.lerp(A[1],B[1],t),Math.lerp(A[2],B[2],t));Vec3.toVec2=(V)=>[V[0],V[1]];Vec3.toVec4=(V)=>[...V,0];Vec3.round=(V)=>[Math.round(V[0]),Math.round(V[1]),Math.round(V[2])];Vec3.floor=(V)=>[Math.floor(V[0]),Math.floor(V[1]),Math.floor(V[2])];Vec3.ceil=(V)=>[Math.ceil(V[0]),Math.ceil(V[1]),Math.ceil(V[2])];Vec3.abs=(V)=>[Math.abs(V[0]),Math.abs(V[1]),Math.abs(V[2])];Object.freeze(Vec3);const Vec4=(x=0,y=0,z=0,w=0)=>[x,y,z,w];Vec4.toString=(V)=>`Vector4(${V[0]},${V[1]},${V[2]},${V[3]})`;Vec4.up=[0,1,0,0];Object.freeze(Vec4.up);Vec4.down=[0,-1,0,0];Object.freeze(Vec4.down);Vec4.left=[-1,0,0,0];Object.freeze(Vec4.left);Vec4.right=[1,0,0,0];Object.freeze(Vec4.right);Vec4.forward=[0,0,1,0];Object.freeze(Vec4.forward);Vec4.back=[0,0,-1,0];Object.freeze(Vec4.back);Vec4.before=[0,0,0,-1];Object.freeze(Vec4.before);Vec4.after=[0,0,0,1];Object.freeze(Vec4.after);Vec4.one=[1,1,1,1];Object.freeze(Vec4.one);Vec4.zero=[0,0,0,0];Object.freeze(Vec4.zero);Vec4.equals=(A,B)=>A===B;Vec4.compare=(A,B)=>A[0]===B[0]&&A[1]===B[1]&&A[2]===B[2]&&A[3]===B[3];Vec4.isNaN=(V)=>V[0]!==V[0]||V[1]!==V[1]||V[2]!==V[2]||V[3]!==V[3];Vec4.repair=(V,d=0)=>[V[0]||d,V[1]||d,V[2]||d,V[3]||d];Vec4.add=(A,B)=>[A[0]+B[0],A[1]+B[1],A[2]+B[2],A[3]+B[3]];Vec4.sub=(A,B)=>[A[0]-B[0],A[1]-B[1],A[2]-B[2],A[3]-B[3]];Vec4.mul=(V,s)=>[V[0]*s,V[1]*s,V[2]*s,V[3]*s];Vec4.dot=(A,B)=>A[0]*B[0]+A[1]*B[1]+A[2]*B[2]+A[3]*B[3];Vec4.scale=(A,B)=>[A[0]*B[0],A[1]*B[1],A[2]*B[2],A[3]*B[3]];Vec4.div=(V,s)=>{const t=1/s;return[V[0]*t,V[1]*t,V[2]*t,V[3]*t]};Vec4.magnitude=(V)=>(V[0]**2+V[1]**2+V[2]**2+V[3]**2)**(1/2);Vec4.sqrMagnitude=(V)=>V[0]**2+V[1]**2+V[2]**2+V[3]**2;Vec4.normalize=(V)=>{const t=1/Vec4.magnitude(V);return[V[0]*t,V[1]*t,V[2]*t,V[3]*t]};Vec4.distance=(A,B)=>((A[0]-B[0])**2+(A[1]-B[1])**2+(A[2]-B[2])**2+(A[3]-B[3])**2)**(1/2);Vec4.angle=(A,B)=>Math.acos(Vec4.dot(A,B)/(Vec4.magnitude(A)*Vec4.magnitude(B)));Vec4.clamp=(V,x,y,z,w)=>[Math.clamp(V[0],...x),Math.clamp(V[1],...y),Math.clamp(V[2],...z),Math.clamp(V[3],...w)];Vec4.simpleClamp=(V,min,max)=>[Math.clamp(V[0],min,max),Math.clamp(V[1],min,max),Math.clamp(V[2],min,max),Math.clamp(V[3],min,max)];Vec4.max=(...V)=>{let o=V[0];for(let i=0;i<V.length;i++){o[0]=V[i][0]>o[0]?V[i][0]:o[0];o[1]=V[i][1]>o[1]?V[i][1]:o[1];o[2]=V[i][2]>o[2]?V[i][2]:o[2];o[3]=V[i][3]>o[3]?V[i][3]:o[3]}return o};Vec4.min=(...V)=>{let o=V[0];for(let i=0;i<V.length;i++){o[0]=V[i][0]<o[0]?V[i][0]:o[0];o[1]=V[i][1]<o[1]?V[i][1]:o[1];o[2]=V[i][2]<o[2]?V[i][2]:o[2];o[3]=V[i][3]<o[3]?V[i][3]:o[3]}return o};Vec4.lerp=(A,B,t)=>[Math.lerp(A[0],B[0],t),Math.lerp(A[1],B[1],t),Math.lerp(A[2],B[2],t),Math.lerp(A[3],B[3],t)];Vec4.toVec2=(V)=>[V[0],V[1]];Vec4.toVec3=(V)=>[V[0],V[1],V[2]];Vec4.round=(V)=>[Math.round(V[0]),Math.round(V[1]),Math.round(V[2]),Math.round(V[3])];Vec4.floor=(V)=>[Math.floor(V[0]),Math.floor(V[1]),Math.floor(V[2]),Math.floor(V[3])];Vec4.ceil=(V)=>[Math.ceil(V[0]),Math.ceil(V[1]),Math.ceil(V[2]),Math.ceil(V[3])];Vec4.abs=(V)=>[Math.abs(V[0]),Math.abs(V[1]),Math.abs(V[2]),Math.abs(V[3])];Object.freeze(Vec3);Math.factorial=(n)=>{let sum=1;while(n>0){sum*=n;n--}return sum};Math.clamp=(v,m,M)=>Math.max(m,Math.min(v,M));Math.lerp=(a,b,t)=>{t=Math.clamp(t,0,1);return a*(1-t)+b*t};Math.lerpUnclamped=(a,b,t)=>a*(1-t)+b*t;Math.deg2rad=1/180*Math.PI;Math.rad2deg=1/Math.PI*180;