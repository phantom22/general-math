const Ax=(a=0,b=0,c=0)=>Vec3.normalize([a,b,c]);Ax.toQuat=(a,b)=>{const c=b/2,d=Math.sin(c);return[a[0]*d,a[1]*d,a[2]*d,Math.cos(c)]},Ax.toString=a=>`Axis(${a[0]},${a[1]},${a[2]})`,Object.freeze(Ax);const Euler=(a=0,b=0,c=0)=>[a,b,c];Euler.toQuat=a=>{const b=Math.sin(.5*a[0]),c=Math.sin(.5*a[1]),d=Math.sin(.5*a[2]),e=Math.cos(.5*a[0]),f=Math.cos(.5*a[1]),g=Math.cos(.5*a[2]);return[b*f*g-e*c*d,e*c*g+b*f*d,e*f*d+b*c*g,e*f*g-b*c*d]},Euler.toString=a=>`Euler<ZXY>(${a[0]}°,${a[1]}°,${a[2]}°)`,Object.freeze(Euler);const Mat3=(...a)=>{const b=Array(9).fill(0);for(let c=0;c<Utils.clamp(a.length,0,9);c++)b[c]=a[c];return b};Mat3.toString=a=>`Matrix3(\n  ${a[0]},${a[1]},${a[2]},\n  ${a[3]},${a[4]},${a[5]},\n  ${a[6]},${a[7]},${a[8]}\n)`,Mat3.identity=[1,0,0,0,1,0,0,0,1],Object.freeze(Mat3.identity),Mat3.zero=[0,0,0,0,0,0,0,0,0],Object.freeze(Mat3.zero),Mat3.det=a=>a[6]*(a[1]*a[5]-a[2]*a[4])-a[7]*(a[0]*a[5]-a[2]*a[3])+a[8]*(a[0]*a[4]-a[1]*a[3]),Mat3.transpose=a=>[a[0],a[3],a[6],a[1],a[4],a[7],a[2],a[5],a[8]],Mat3.invert=j=>{let k=Mat3.det(j);if(0===k)return Mat3.zero;k=1/k;const[l,a,b,c,d,e,f,g,h]=j;return[(d*e-g*h)*k,(-a*h+b*g)*k,(a*e-b*d)*k,(-c*h+e*f)*k,(l*h-b*f)*k,(-l*e+b*c)*k,(c*g-d*f)*k,(-l*g+a*f)*k,(l*d-a*c)*k]},Mat3.isIdentity=a=>1===a[0]&&0===a[1]&&0===a[2]&&0===a[3]&&1===a[4]&&0===a[5]&&0===a[6]&&0===a[7]&&1===a[8],Mat3.prod=(j,k)=>{const[l,a,b,c,d,e,f,g,h]=j,[i,m,n,o,p,q,r,s,t]=k;return[l*i+a*o+b*r,l*m+a*p+b*s,l*n+a*q+b*t,c*i+d*o+e*r,c*m+d*p+e*s,c*n+d*q+e*t,f*i+g*o+h*r,f*m+g*p+h*s,f*n+g*q+h*t]},Mat3.scale=(a,b)=>[a[0]*b[0],a[1]*b[0],a[2]*b[0],a[3]*b[1],a[4]*b[1],a[5]*b[1],a[6],a[7],a[8]],Mat3.getCol=(a,b)=>[a[b],a[3+b],a[6+b]],Mat3.getRow=(a,b)=>{const c=3*b;return[a[c],a[c+1],a[c+2]]},Mat3.toNormalMat=a=>Mat3.transpose(Mat3.invert(a)),Mat3.toEuler=a=>{const b=Math.asin(Utils.clamp(a[7],-1,1));return .9999999>Math.abs(a[7])?[b,Math.atan2(-a[6],a[8]),Math.atan2(-a[1],a[4])]:[b,0,Math.atan2(a[3],a[1])]},Mat3.toMat4=a=>[a[0],a[3],a[6],0,a[1],a[4],a[7],0,a[2],a[5],a[8],0,0,0,0,1],Object.freeze(Mat3);const Mat4=(...a)=>{const b=Array(16).fill(0);for(let c=0;c<Utils.clamp(a.length,0,16);c++)b[c]=a[c];return b};Mat4.toString=a=>`Matrix4(\n  ${a[0]},${a[1]},${a[2]},${a[3]},\n  ${a[4]},${a[5]},${a[6]},${a[7]},\n  ${a[8]},${a[9]},${a[10]},${a[11]},\n  ${a[12]},${a[13]},${a[14]},${a[15]}\n)`,Mat4.identity=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],Object.freeze(Mat4.identity),Mat4.zero=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],Object.freeze(Mat4.zero),Mat4.det=a=>-a[12]*(a[9]*(a[2]*a[7]-a[3]*a[6])-a[10]*(a[1]*a[7]-a[3]*a[5])+a[11]*(a[1]*a[6]-a[2]*a[5]))+a[13]*(a[8]*(a[2]*a[7]-a[3]*a[6])-a[10]*(a[0]*a[7]-a[3]*a[4])+a[11]*(a[0]*a[6]-a[2]*a[4]))-a[14]*(a[8]*(a[1]*a[7]-a[3]*a[5])-a[9]*(a[0]*a[7]-a[3]*a[4])+a[11]*(a[0]*a[5]-a[1]*a[4]))+a[15]*(a[8]*(a[1]*a[6]-a[2]*a[5])-a[9]*(a[0]*a[6]-a[2]*a[4])+a[10]*(a[0]*a[5]-a[1]*a[4])),Mat4.transpose=a=>[a[0],a[4],a[8],a[12],a[1],a[5],a[9],a[13],a[2],a[6],a[10],a[14],a[3],a[7],a[11],a[15]],Mat4.invert=q=>{let r=Mat4.det(q);if(0===r)return Mat4.zero;r=1/r;const[s,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o]=q,p=j*o-k*n,t=i*o-k*m,u=i*n-j*m,v=h*o-k*l,w=h*n-j*l,x=h*m-i*l,y=f*o-g*n,z=e*o-g*m,A=e*n-f*m,B=d*o-g*l,C=d*n-f*l,D=d*m-e*l,E=f*k-g*j,F=e*k-g*i,G=e*j-f*i,H=d*k-g*h,I=d*j-f*h,J=d*i-e*h;return[(e*p-f*t+g*u)*r,(-a*p+b*t-c*u)*r,(a*y-b*z+c*A)*r,(-a*E+b*F-c*G)*r,(-d*p+f*v-g*w)*r,(s*p-b*v+c*w)*r,(-s*y+b*B-c*C)*r,(s*E-b*H+c*I)*r,(d*t-f*v+g*w)*r,(-s*t+a*v-c*x)*r,(s*z-a*B+c*D)*r,(-s*F+a*H-c*J)*r,(-d*u+e*w-f*x)*r,(s*u-a*w+b*x)*r,(-s*A+a*C-b*D)*r,(s*G-a*I+b*J)*r]},Mat4.isIdentity=a=>1===a[0]&&0===a[1]&&0===a[2]&&0===a[3]&&0===a[4]&&1===a[5]&&0===a[6]&&0===a[7]&&0===a[8]&&0===a[9]&&1===a[10]&&0===a[11]&&0===a[12]&&0===a[13]&&0===a[14]&&1===a[15],Mat4.prod=(q,r)=>{const[s,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o]=q,[p,t,u,v,w,x,y,z,A,B,C,D,E,F,G,H]=r;return[s*p+a*w+b*A+c*E,s*t+a*x+b*B+c*F,s*u+a*y+b*C+c*G,s*v+a*z+b*D+c*H,d*p+e*w+f*A+g*E,d*t+e*x+f*B+g*F,d*u+e*y+f*C+g*G,d*v+e*z+f*D+g*H,h*p+i*w+j*A+k*E,h*t+i*x+j*B+k*F,h*u+i*y+j*C+k*G,h*v+i*z+j*D+k*H,l*p+m*w+n*A+o*E,l*t+m*x+n*B+o*F,l*u+m*y+n*C+o*G,l*v+m*z+n*D+o*H]},Mat4.scale=(a,b)=>[a[0]*b[0],a[1]*b[0],a[2]*b[0],a[3]*b[0],a[4]*b[1],a[5]*b[1],a[6]*b[1],a[7]*b[1],a[8]*b[2],a[9]*b[2],a[10]*b[2],a[11]*b[2],a[12],a[13],a[14],a[15]],Mat4.getCol=(a,b)=>[a[b],a[4+b],a[8+b],a[12+b]],Mat4.getRow=(a,b)=>{const c=4*b;return[a[c],a[c+1],a[c+2],a[c+3]]},Mat4.compose=(a,b,c)=>{const[d,e,f,g]=b,h=2*d**2,i=2*e**2,j=2*f**2,k=2*d*e,l=2*g*f,m=2*d*f,n=2*g*e,o=2*e*f,p=2*g*d,[q,r,s]=c;return[(1-i-j)*q,(k+l)*q,(m-n)*q,0,(k-l)*r,(1-h-j)*r,(o+p)*r,0,(m+n)*s,(o-p)*s,(1-h-i)*s,0,...a,1]},Mat4.toEuler=a=>{const b=Math.asin(Utils.clamp(a[6],-1,1));return .9999999>Math.abs(a[6])?[b,Math.atan2(-a[2],a[10]),Math.atan2(-a[4],a[5])]:[b,0,Math.atan2(a[1],a[0])]},Mat4.toMat3=a=>[a[0],a[4],a[8],a[1],a[5],a[9],a[2],a[6],a[10]],Mat4.toNormalMat=a=>Mat3.transpose(Mat3.invert(Mat4.toMat3(a))),Object.freeze(Mat4);const Quat=(a=0,b=0,c=0,d=1)=>[a,b,c,d];Quat.toString=a=>`Quaternion(${a[0]},${a[1]},${a[2]},${a[3]})`,Quat.dot=(a,b)=>a[0]*b[0]+a[1]*b[1]+a[2]*b[2]+a[3]*b[3],Quat.identity=[0,0,0,1],Object.freeze(Quat.identity),Quat.angle=(a,b)=>2*Math.acos(Math.abs(Utils.clamp(Quat.dot(a,b),-1,1))),Quat.prod=(a,b)=>[a[0]*b[3]+a[3]*b[0]+a[1]*b[2]-a[2]*b[1],a[1]*b[3]+a[3]*b[1]+a[2]*b[2]-a[0]*b[2],a[2]*b[3]+a[3]*b[2]+a[0]*b[1]-a[1]*b[0],a[3]*b[3]+a[0]*b[0]+a[1]*b[1]-a[2]*b[2]],Quat.equals=(a,b)=>a===b,Quat.compare=(a,b)=>a[0]===b[0]&&a[1]===b[1]&&a[2]===b[2]&&a[3]===b[3],Quat.magnitude=a=>(a[0]**2+a[1]**2+a[2]**2+a[3]**2)**.5,Quat.sqrdMagnitude=a=>a[0]**2+a[1]**2+a[2]**2+a[3]**2,Quat.inverse=a=>{const b=1/Quat.sqrdMagnitude(a);return[a[0]*b,-a[1]*b,-a[2]*b,-a[3]*b]},Quat.toEuler=a=>{const b=2*Math.acos(a[3])/180*Math.PI,d=1-Math.cos(b),c=Math.sin(b)**2+Math.sin(b),e=Math.sin(b)**2-Math.sin(b),f=Math.asin(Utils.clamp(e*(a[0]*a[2]-a[2]),-1,1));return .9999999>Math.abs(f)?[Math.atan2(c*(a[1]*a[2]+a[2]),1+(-(a[0]**2)-a[1]**2)*d),f,Math.atan2(c*(a[0]*a[1]-a[2]),1+(-(a[1]**2)-a[2]**2)*d)]:[0,f,Math.atan2(-e*(a[0]*a[1]-a[2]),1+(-(a[0]**2)-a[2]**2)*d)]},Quat.toMat4=a=>{const[b,c,d,e]=a,f=2*b**2,g=2*c**2,h=2*d**2,i=2*b*c,j=2*e*d,k=2*b*d,l=2*e*c,m=2*c*d,n=2*e*b;return[1-g-h,i+j,k-l,0,i-j,1-f-h,m+n,0,k+l,m-n,1-f-g,0,0,0,0,1]},Quat.toMat3=a=>{const[b,c,d,e]=a,f=2*b**2,g=2*c**2,h=2*d**2,i=2*b*c,j=2*e*d,k=2*b*d,l=2*e*c,m=2*c*d,n=2*e*b;return[1-g-h,i-j,k+l,i+j,1-f-h,m-n,k-l,m+n,1-f-g]},Quat.toEuler=a=>Mat4.toEuler(Quat.toMat4(a)),Object.freeze(Quat);const Vec2=(a=0,b=0)=>[a,b];Vec2.toString=a=>`Vector2(${a[0]},${a[1]})`,Vec2.up=[0,1],Object.freeze(Vec2.up),Vec2.down=[0,-1],Object.freeze(Vec2.down),Vec2.left=[-1,0],Object.freeze(Vec2.left),Vec2.right=[1,0],Object.freeze(Vec2.right),Vec2.one=[1,1],Object.freeze(Vec2.one),Vec2.zero=[0,0],Object.freeze(Vec2.zero),Vec2.equals=(a,b)=>a===b,Vec2.compare=(a,b)=>a[0]===b[0]&&a[1]===b[1],Vec2.isNaN=a=>a[0]!==a[0]||a[1]!==a[1],Vec2.repair=(a,b=0)=>[a[0]||b,a[1]||b],Vec2.add=(a,b)=>[a[0]+b[0],a[1]+b[1]],Vec2.sub=(a,b)=>[a[0]-b[0],a[1]-b[1]],Vec2.mul=(a,b)=>[a[0]*b,a[1]*b],Vec2.dot=(a,b)=>a[0]*b[0]+a[1]*b[1],Vec2.scale=(a,b)=>[a[0]*b[0],a[1]*b[1]],Vec2.div=(a,b)=>{const c=1/b;return[a[0]*c,a[1]*c]},Vec2.magnitude=a=>(a[0]**2+a[1]**2)**(1/2),Vec2.sqrMagnitude=a=>a[0]**2+a[1]**2,Vec2.normalize=a=>{const b=1/Vec2.magnitude(a);return[a[0]*b,a[1]*b]},Vec2.distance=(a,b)=>((a[0]-b[0])**2+(a[1]-b[1])**2)**(1/2),Vec2.cross=(a,b)=>[0,0,-a[0]*b[1]+a[1]*b[0]],Vec2.angle=(a,b)=>Math.acos(Vec2.dot(a,b)/(Vec2.magnitude(a)*Vec2.magnitude(b))),Vec2.clamp=(a,b,c)=>[Utils.clamp(a[0],...b),Utils.clamp(a[1],...c)],Vec2.simpleClamp=(a,b,c)=>[Utils.clamp(a[0],b,c),Utils.clamp(a[1],b,c)],Vec2.max=(...a)=>{let b=a[0];for(let c=0;c<a.length;c++)b[0]=a[c][0]>b[0]?a[c][0]:b[0],b[1]=a[c][1]>b[1]?a[c][1]:b[1];return b},Vec2.min=(...a)=>{let b=a[0];for(let c=0;c<a.length;c++)b[0]=a[c][0]<b[0]?a[c][0]:b[0],b[1]=a[c][1]<b[1]?a[c][1]:b[1];return b},Vec2.lerp=(a,b,c)=>[Utils.lerp(a[0],b[0],c),Utils.lerp(a[1],b[1],c)],Vec2.toVec3=a=>[...a,0],Vec2.toVec4=a=>[...a,0,0],Vec2.round=a=>[Math.round(a[0]),Math.round(a[1])],Vec2.floor=a=>[Math.floor(a[0]),Math.floor(a[1])],Vec2.ceil=a=>[Math.ceil(a[0]),Math.ceil(a[1])],Vec2.abs=a=>[Math.abs(a[0]),Math.abs(a[1])],Object.freeze(Vec2);const Vec3=(a=0,b=0,c=0)=>[a,b,c];Vec3.toString=a=>`Vector3(${a[0]},${a[1]},${a[2]})`,Vec3.up=[0,1,0],Object.freeze(Vec3.up),Vec3.down=[0,-1,0],Object.freeze(Vec3.down),Vec3.left=[-1,0,0],Object.freeze(Vec3.left),Vec3.right=[1,0,0],Object.freeze(Vec3.right),Vec3.forward=[0,0,1],Object.freeze(Vec3.forward),Vec3.back=[0,0,-1],Object.freeze(Vec3.back),Vec3.one=[1,1,1],Object.freeze(Vec3.one),Vec3.zero=[0,0,0],Object.freeze(Vec3.zero),Vec3.equals=(a,b)=>a===b,Vec3.compare=(a,b)=>a[0]===b[0]&&a[1]===b[1]&&a[2]===b[2],Vec3.isNaN=a=>a[0]!==a[0]||a[1]!==a[1]||a[2]!==a[2],Vec3.repair=(a,b=0)=>[a[0]||b,a[1]||b,a[2]||b],Vec3.add=(a,b)=>[a[0]+b[0],a[1]+b[1],a[2]+b[2]],Vec3.sub=(a,b)=>[a[0]-b[0],a[1]-b[1],a[2]-b[2]],Vec3.mul=(a,b)=>[a[0]*b,a[1]*b,a[2]*b],Vec3.dot=(a,b)=>a[0]*b[0]+a[1]*b[1]+a[2]*b[2],Vec3.scale=(a,b)=>[a[0]*b[0],a[1]*b[1],a[2]*b[2]],Vec3.div=(a,b)=>{const c=1/b;return[a[0]*c,a[1]*c,a[2]*c]},Vec3.magnitude=a=>(a[0]**2+a[1]**2+a[2]**2)**(1/2),Vec3.sqrMagnitude=a=>a[0]**2+a[1]**2+a[2]**2,Vec3.normalize=a=>{const b=1/Vec3.magnitude(a);return[a[0]*b,a[1]*b,a[2]*b]},Vec3.distance=(a,b)=>((a[0]-b[0])**2+(a[1]-b[1])**2+(a[2]-b[2])**2)**(1/2),Vec3.cross=(a,b)=>[a[1]*b[2]-a[2]*b[1],a[0]*b[2]-a[2]*b[0],a[0]*b[1]-a[1]*b[0]],Vec3.angle=(a,b)=>Math.acos(Vec3.dot(a,b)/(Vec3.magnitude(a)*Vec3.magnitude(b))),Vec3.clamp=(a,b,c,d)=>[Utils.clamp(a[0],...b),Utils.clamp(a[1],...c),Utils.clamp(a[2],...d)],Vec3.simpleClamp=(a,b,c)=>[Utils.clamp(a[0],b,c),Utils.clamp(a[1],b,c),Utils.clamp(a[2],b,c)],Vec3.max=(...a)=>{let b=a[0];for(let c=0;c<a.length;c++)b[0]=a[c][0]>b[0]?a[c][0]:b[0],b[1]=a[c][1]>b[1]?a[c][1]:b[1],b[2]=a[c][2]>b[2]?a[c][2]:b[2];return b},Vec3.min=(...a)=>{let b=a[0];for(let c=0;c<a.length;c++)b[0]=a[c][0]<b[0]?a[c][0]:b[0],b[1]=a[c][1]<b[1]?a[c][1]:b[1],b[2]=a[c][2]<b[2]?a[c][2]:b[2];return b},Vec3.lerp=(a,b,c)=>Vec3(Utils.lerp(a[0],b[0],c),Utils.lerp(a[1],b[1],c),Utils.lerp(a[2],b[2],c)),Vec3.toVec2=a=>[a[0],a[1]],Vec3.toVec4=a=>[...a,0],Vec3.round=a=>[Math.round(a[0]),Math.round(a[1]),Math.round(a[2])],Vec3.floor=a=>[Math.floor(a[0]),Math.floor(a[1]),Math.floor(a[2])],Vec3.ceil=a=>[Math.ceil(a[0]),Math.ceil(a[1]),Math.ceil(a[2])],Vec3.abs=a=>[Math.abs(a[0]),Math.abs(a[1]),Math.abs(a[2])],Object.freeze(Vec3);const Vec4=(a=0,b=0,c=0,d=0)=>[a,b,c,d];Vec4.toString=a=>`Vector4(${a[0]},${a[1]},${a[2]},${a[3]})`,Vec4.up=[0,1,0,0],Object.freeze(Vec4.up),Vec4.down=[0,-1,0,0],Object.freeze(Vec4.down),Vec4.left=[-1,0,0,0],Object.freeze(Vec4.left),Vec4.right=[1,0,0,0],Object.freeze(Vec4.right),Vec4.forward=[0,0,1,0],Object.freeze(Vec4.forward),Vec4.back=[0,0,-1,0],Object.freeze(Vec4.back),Vec4.before=[0,0,0,-1],Object.freeze(Vec4.before),Vec4.after=[0,0,0,1],Object.freeze(Vec4.after),Vec4.one=[1,1,1,1],Object.freeze(Vec4.one),Vec4.zero=[0,0,0,0],Object.freeze(Vec4.zero),Vec4.equals=(a,b)=>a===b,Vec4.compare=(a,b)=>a[0]===b[0]&&a[1]===b[1]&&a[2]===b[2]&&a[3]===b[3],Vec4.isNaN=a=>a[0]!==a[0]||a[1]!==a[1]||a[2]!==a[2]||a[3]!==a[3],Vec4.repair=(a,b=0)=>[a[0]||b,a[1]||b,a[2]||b,a[3]||b],Vec4.add=(a,b)=>[a[0]+b[0],a[1]+b[1],a[2]+b[2],a[3]+b[3]],Vec4.sub=(a,b)=>[a[0]-b[0],a[1]-b[1],a[2]-b[2],a[3]-b[3]],Vec4.mul=(a,b)=>[a[0]*b,a[1]*b,a[2]*b,a[3]*b],Vec4.dot=(a,b)=>a[0]*b[0]+a[1]*b[1]+a[2]*b[2]+a[3]*b[3],Vec4.scale=(a,b)=>[a[0]*b[0],a[1]*b[1],a[2]*b[2],a[3]*b[3]],Vec4.div=(a,b)=>{const c=1/b;return[a[0]*c,a[1]*c,a[2]*c,a[3]*c]},Vec4.magnitude=a=>(a[0]**2+a[1]**2+a[2]**2+a[3]**2)**(1/2),Vec4.sqrMagnitude=a=>a[0]**2+a[1]**2+a[2]**2+a[3]**2,Vec4.normalize=a=>{const b=1/Vec4.magnitude(a);return[a[0]*b,a[1]*b,a[2]*b,a[3]*b]},Vec4.distance=(a,b)=>((a[0]-b[0])**2+(a[1]-b[1])**2+(a[2]-b[2])**2+(a[3]-b[3])**2)**(1/2),Vec4.angle=(a,b)=>Math.acos(Vec4.dot(a,b)/(Vec4.magnitude(a)*Vec4.magnitude(b))),Vec4.clamp=(a,b,c,d,e)=>[Utils.clamp(a[0],...b),Utils.clamp(a[1],...c),Utils.clamp(a[2],...d),Utils.clamp(a[3],...e)],Vec4.simpleClamp=(a,b,c)=>[Utils.clamp(a[0],b,c),Utils.clamp(a[1],b,c),Utils.clamp(a[2],b,c),Utils.clamp(a[3],b,c)],Vec4.max=(...a)=>{let b=a[0];for(let c=0;c<a.length;c++)b[0]=a[c][0]>b[0]?a[c][0]:b[0],b[1]=a[c][1]>b[1]?a[c][1]:b[1],b[2]=a[c][2]>b[2]?a[c][2]:b[2],b[3]=a[c][3]>b[3]?a[c][3]:b[3];return b},Vec4.min=(...a)=>{let b=a[0];for(let c=0;c<a.length;c++)b[0]=a[c][0]<b[0]?a[c][0]:b[0],b[1]=a[c][1]<b[1]?a[c][1]:b[1],b[2]=a[c][2]<b[2]?a[c][2]:b[2],b[3]=a[c][3]<b[3]?a[c][3]:b[3];return b},Vec4.lerp=(a,b,c)=>[Utils.lerp(a[0],b[0],c),Utils.lerp(a[1],b[1],c),Utils.lerp(a[2],b[2],c),Utils.lerp(a[3],b[3],c)],Vec4.toVec2=a=>[a[0],a[1]],Vec4.toVec3=a=>[a[0],a[1],a[2]],Vec4.round=a=>[Math.round(a[0]),Math.round(a[1]),Math.round(a[2]),Math.round(a[3])],Vec4.floor=a=>[Math.floor(a[0]),Math.floor(a[1]),Math.floor(a[2]),Math.floor(a[3])],Vec4.ceil=a=>[Math.ceil(a[0]),Math.ceil(a[1]),Math.ceil(a[2]),Math.ceil(a[3])],Vec4.abs=a=>[Math.abs(a[0]),Math.abs(a[1]),Math.abs(a[2]),Math.abs(a[3])],Object.freeze(Vec3);const Utils=()=>void 0;Utils.factorial=a=>{let b=1;for(;0<a;)b*=a,a--;return b},Utils.clamp=(a,b,c)=>Math.max(b,Math.min(a,c)),Utils.lerp=(c,a,b)=>(b=Utils.clamp(b,0,1),c*(1-b)+a*b),Utils.lerpUnclamped=(c,a,b)=>c*(1-b)+a*b,Utils.deg2rad=1/180*Math.PI,Utils.rad2deg=180*(1/Math.PI),Object.freeze(Utils);