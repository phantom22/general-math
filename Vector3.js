const Vec3 = (x, y, z) => {
    let v = [x, y, z];
    v.toString = () => `Vector3(${v[0]},${v[1]},${v[2]})`;
    return v;
};
Vec3.up = [0, 1, 0];
Vec3.down = [0, -1, 0];
Vec3.left = [-1, 0, 0];
Vec3.right = [1, 0, 0];
Vec3.forward = [0, 0, 1];
Vec3.back = [0, 0, -1];
Vec3.one = [1, 1, 0];
Vec3.zero = [0, 0, 0];
Vec3.equals = (a, b) => a === b;
Vec3.compare = (a, b) => a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
Vec3.isNaN = (v) => Number.isNaN(v[0]) || Number.isNaN(v[1]) || Number.isNaN(v[2]);
Vec3.repair = (v, d = 0) => [v[0] || d, v[1] || d, v[2] || d];
Vec3.clone = (v) => [...v];
Vec3.add = (a, b) => [a[0] + b[0], a[1] + b[1], a[2] + b[2]];
Vec3.sub = (a, b) => [a[0] - b[0], a[1] - b[1], a[2] - b[2]];
Vec3.mul = (v, s) => [v[0] * s, v[1] * s, v[2] * s];
Vec3.dot = (a, b) => a[0] * b[0] + a[1] * b[1];
Vec3.scale = (a, b) => [a[0] * b[0], a[1] * b[1], a[2] * b[2]];
Vec3.div = (v, s) => { const t = 1 / s; return [v[0] * t, v[1] * t, v[2] * t]; };
Vec3.magnitude = (v) => (v[0] ** 2 + v[1] ** 2 + v[2] ** 2) ** (1 / 2);
Vec3.sqrMagnitude = (v) => v[0] ** 2 + v[1] ** 2 + v[2] ** 2;
Vec3.normalize = (v) => { const t = 1 / Vec3.magnitude(v); return [v[0] * t, v[1] * t, v[2] * t]; };
Vec3.distance = (a, b) => ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2) ** (1 / 2);
Vec3.angle = (a, b) => Math.acos(Vec3.dot(a, b) / (Vec3.magnitude(a) * Vec3.magnitude(b)));
Vec3.clamp = (v, x, y, z) => [Math.max(x[0], Math.min(v[0], x[1])), Math.max(y[0], Math.min(v[1], y[1])), Math.max(z[0], Math.min(v[2], z[1]))];
Vec3.simpleClamp = (v, min, max) => [Math.max(min, Math.min(v[0], max)), Math.max(min, Math.min(v[1], max)), Math.max(min, Math.min(v[2], max))];
Vec3.max = (...v) => { let o = v[0]; for (let i = 0; i < v.length; i++) {
    o[0] = v[i][0] > o[0] ? v[i][0] : o[0];
    o[1] = v[i][1] > o[1] ? v[i][1] : o[1];
    o[2] = v[i][2] > o[2] ? v[i][2] : o[2];
} return o; };
Vec3.min = (...v) => { let o = v[0]; for (let i = 0; i < v.length; i++) {
    o[0] = v[i][0] < o[0] ? v[i][0] : o[0];
    o[1] = v[i][1] < o[1] ? v[i][1] : o[1];
    o[2] = v[i][2] < o[2] ? v[i][2] : o[2];
} return o; };
Vec3.lerp = (a, b, t) => Vec3(a[0] * (1 - t) + b[0] * t, a[1] * (1 - t) + b[1] * t, a[2] * (1 - t) + b[2] * t);
Object.freeze(Vec3);
